-- =====================================================
-- BC: Requests — Esquema, tablas y llaves
-- =====================================================

CREATE SCHEMA IF NOT EXISTS requests;

-- =====================================================
-- Catálogos (normalizados)
-- =====================================================

-- Estados de la solicitud
CREATE TABLE IF NOT EXISTS requests.request_statuses (
    status_id   INT PRIMARY KEY,
    code        VARCHAR(32) NOT NULL UNIQUE  -- OPEN | CLOSED | CANCELLED | EXPIRED
    );

-- Motivos de cierre/cambio de estado (no canónico de Planning)
CREATE TABLE IF NOT EXISTS requests.request_close_reasons (
    reason_id   INT PRIMARY KEY,
    code        VARCHAR(32) NOT NULL UNIQUE  -- USER_CLOSED | MATCHED | TIMEOUT | CANCELLED
    );

-- Estados del outbox de envío a Planning
CREATE TABLE IF NOT EXISTS requests.outbox_statuses (
    outbox_status_id INT PRIMARY KEY,
    code             VARCHAR(16) NOT NULL UNIQUE  -- PENDING | SENT | DEAD
    );

-- =====================================================
-- Tabla principal: requests
-- =====================================================
CREATE TABLE IF NOT EXISTS requests.requests (
    request_id                 INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    requester_account_id       INT           NOT NULL,
    requester_name_snapshot    VARCHAR(200),           -- snapshot de nombre (no DNI)

    status_id                  INT           NOT NULL REFERENCES requests.request_statuses(status_id),

    -- Timestamps: los setea la app (sin defaults/trigger)
    created_at                 TIMESTAMPTZ   NOT NULL,
    updated_at                 TIMESTAMPTZ   NOT NULL,
    closed_at                  TIMESTAMPTZ,

    -- Origen (snapshot validado por ACL Geo; sin FK directa para no acoplar)
    origin_department_code     CHAR(2)       NOT NULL,
    origin_department_name     VARCHAR(100)  NOT NULL,
    origin_province_code       CHAR(4),
    origin_province_name       VARCHAR(100),
    origin_district_text       VARCHAR(150),

    -- Destino
    dest_department_code       CHAR(2)       NOT NULL,
    dest_department_name       VARCHAR(100)  NOT NULL,
    dest_province_code         CHAR(4),
    dest_province_name         VARCHAR(100),
    dest_district_text         VARCHAR(150),

    -- Agregados opcionales para listados rápidos (no calculados aquí)
    items_count                INT,
    total_weight_kg            NUMERIC(12,3),

    -- Sanidad básica
    CONSTRAINT chk_requests_items_count_nonneg
    CHECK (items_count IS NULL OR items_count >= 0),
    CONSTRAINT chk_requests_total_weight_nonneg
    CHECK (total_weight_kg IS NULL OR total_weight_kg >= 0)
    );

-- Índices útiles para listados
CREATE INDEX IF NOT EXISTS ix_requests_status_createdat
    ON requests.requests (status_id, created_at DESC);

CREATE INDEX IF NOT EXISTS ix_requests_requester_createdat
    ON requests.requests (requester_account_id, created_at DESC);

CREATE INDEX IF NOT EXISTS ix_requests_createdat
    ON requests.requests (created_at DESC);

-- =====================================================
-- Ítems de la solicitud
-- =====================================================
CREATE TABLE IF NOT EXISTS requests.request_items (
    item_id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    request_id        INT NOT NULL REFERENCES requests.requests(request_id) ON DELETE CASCADE,

    item_name         VARCHAR(160) NOT NULL,
    height_cm         NUMERIC(8,2),
    width_cm          NUMERIC(8,2),
    length_cm         NUMERIC(8,2),
    weight_kg         NUMERIC(10,3),
    total_weight_kg   NUMERIC(10,3),
    quantity          INT NOT NULL,
    fragile           BOOLEAN NOT NULL DEFAULT FALSE,
    notes             VARCHAR(400),

    position          INT NOT NULL,

    -- Sanidad
    CONSTRAINT chk_item_dims_nonneg CHECK (
(height_cm IS NULL OR height_cm >= 0) AND
(width_cm  IS NULL OR width_cm  >= 0) AND
(length_cm IS NULL OR length_cm >= 0)
    ),
    CONSTRAINT chk_item_weights_nonneg CHECK (
(weight_kg IS NULL OR weight_kg >= 0) AND
(total_weight_kg IS NULL OR total_weight_kg >= 0)
    ),
    CONSTRAINT chk_item_quantity_pos CHECK (quantity > 0),
    CONSTRAINT chk_item_position_pos CHECK (position >= 1),

    -- Evitar posiciones repetidas dentro de la misma request
    CONSTRAINT uq_request_items_request_pos UNIQUE (request_id, position)
    );

CREATE INDEX IF NOT EXISTS ix_request_items_request_pos
    ON requests.request_items (request_id, position);

-- =====================================================
-- Imágenes por ítem (sólo URL)
-- =====================================================
CREATE TABLE IF NOT EXISTS requests.request_item_images (
                                                            image_id        INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                                            item_id         INT NOT NULL REFERENCES requests.request_items(item_id) ON DELETE CASCADE,
    image_url       TEXT NOT NULL,
    image_position  INT  NOT NULL,

    CONSTRAINT chk_image_position_pos CHECK (image_position >= 1),
    CONSTRAINT uq_request_item_images_item_pos UNIQUE (item_id, image_position)
    );

CREATE INDEX IF NOT EXISTS ix_request_item_images_item_pos
    ON requests.request_item_images (item_id, image_position);

-- =====================================================
-- Historial de estados
-- =====================================================
CREATE TABLE IF NOT EXISTS requests.request_status_history (
    history_id              INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    request_id              INT NOT NULL REFERENCES requests.requests(request_id) ON DELETE CASCADE,

    from_status_id          INT REFERENCES requests.request_statuses(status_id),
    to_status_id            INT NOT NULL REFERENCES requests.request_statuses(status_id),

    reason_id               INT REFERENCES requests.request_close_reasons(reason_id),
    notes                   VARCHAR(400),

    changed_by_account_id   INT,
    changed_at              TIMESTAMPTZ NOT NULL
    );

CREATE INDEX IF NOT EXISTS ix_request_status_history_req_changedat
    ON requests.request_status_history (request_id, changed_at DESC);

-- =====================================================
-- Outbox para invocar Planning.matchAndNotify (resiliencia)
-- Regla: 1 fila por request (UNIQUE), se marca SENT o se elimina al confirmarse.
-- =====================================================
CREATE TABLE IF NOT EXISTS requests.outbox_planning_match (
    outbox_id                INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    request_id               INT NOT NULL UNIQUE
    REFERENCES requests.requests(request_id) ON DELETE CASCADE,

    origin_department_code   CHAR(2)     NOT NULL,
    origin_province_code     CHAR(4),
    dest_department_code     CHAR(2)     NOT NULL,
    dest_province_code       CHAR(4),

    created_at               TIMESTAMPTZ NOT NULL,
    next_attempt_at          TIMESTAMPTZ NOT NULL,
    attempt_count            INT         NOT NULL DEFAULT 0,
    last_error               TEXT,

    locked_at                TIMESTAMPTZ,
    outbox_status_id         INT NOT NULL REFERENCES requests.outbox_statuses(outbox_status_id),

    CONSTRAINT chk_outbox_attempt_count_nonneg CHECK (attempt_count >= 0)
    );

CREATE INDEX IF NOT EXISTS ix_outbox_match_status_nextattempt
    ON requests.outbox_planning_match (outbox_status_id, next_attempt_at);

CREATE INDEX IF NOT EXISTS ix_outbox_match_locked_at
    ON requests.outbox_planning_match (locked_at);
